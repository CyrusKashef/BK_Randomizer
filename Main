'''
Created on Mar 1, 2021

@author: Cyrus
'''

###########################################################################
################################# IMPORTS #################################
###########################################################################

import mmap
import random
import os
import shutil
import tkinter.filedialog
import tkinter as tk

#####################################################################################
##################################### VARIABLES #####################################
#####################################################################################

#file_dir = os.getcwd() + "\\"
tmp_folder = "EPPIIISA\\"

#############################################################################################
####################################### SETUP ID LIST #######################################
#############################################################################################

setup_ids = {
    # Setup Location
        # Setup Address
        # Header -> GEDecompressor decompressed file's compressed characters that are different from the default compressed header
        # Footer -> GEDecompressor decompressed file's compressed characters that are different from the default compressed footer
        # Lead -> Compressed file's original header (grab first 10 hex from rom)
        # Tail -> Compressed file's original footer (grab from rom)
    "Spiral Mountain": [
        ("0x9780", # Main Area - 4C4680
            ["1F", "8B", "08", "08", "C0", "A9", "47", "60", "00", "0B", "34", "43", "34", "36", "38", "30", "2D", "41", "63", "74", "75", "61", "6C", "5F", "44", "65", "63", "6F", "6D", "70", "72", "65", "73", "73", "65", "64", "2E", "62", "69", "6E", "00"],
            ["F5", "0F", "4E", "05", "A0", "26", "00", "00"],
            ['11', '72', '00', '00', '26', 'A0'],
            ['AA', 'AA', 'AA'],
            ),
        ],
    "Mumbo's Mountain": [
        ("0x9788", # Main Area - 4C5A30
            ["1F", "8B", "08", "08", "C0", "A9", "47", "60", "00", "0B", "34", "43", "35", "41", "33", "30", "2D", "41", "63", "74", "75", "61", "6C", "5F", "44", "65", "63", "6F", "6D", "70", "72", "65", "73", "73", "65", "64", "2E", "62", "69", "6E", "00"],
            ["07", "D0", "9F", "9C", "10", "39", "00", "00"],
            ["11", "72", "00", "00", "39", "10"],
            []),
        ("0x97D8", # Ticker's Tower - 4CCD40
            ["1F", "8B", "08", "08", "8E", "D1", "50", "60", "00", "0B", "34", "43", "43", "44", "34", "30", "2D", "41", "63", "74", "75", "61", "6C", "5F", "44", "65", "63", "6F", "6D", "70", "72", "65", "73", "73", "65", "64", "2E", "62", "69", "6E", "00"],
            ["09", "CE", "33", "CD", "97", "07", "00", "00"],
            ["11", "72", "00", "00", "07", "97"],
            ["AA", "AA", "AA", "AA"]
            ),
        ("0x97E8", # Mumbo's Skull - 4CF158
            ["1F", "8B", "08", "08", "8E", "D1", "50", "60", "00", "0B", "34", "43", "46", "31", "35", "38", "2D", "41", "63", "74", "75", "61", "6C", "5F", "44", "65", "63", "6F", "6D", "70", "72", "65", "73", "73", "65", "64", "2E", "62", "69", "6E", "00"],
            ["57", "06", "86", "0A", "1B", "04", "00", "00"],
            ["11", "72", "00", "00", "04", "1B"],
            ["AA", "AA", "AA", "AA"]
            ),
        ],
####################################################
#     "Mad Monster Mansion": [
#         ("0x9850", # Main Area - 4D44D8
#         ["1F", "8B", "08", "08", "8F", "D1", "50", "60", "00", "0B", "34", "44", "34", "34", "44", "38", "2D", "41", "63", "74", "75", "61", "6C", "5F", "44", "65", "63", "6F", "6D", "70", "72", "65", "73", "73", "65", "64", "2E", "62", "69", "6E", "00"],
#         ["A9", "19", "C5", "C7", "51", "45", "00", "00"],
#         ["11", "72", "00", "00", "45", "51"],
#         ["AA", "AA", "AA", "AA"]
#         ),
#         ],
    }

###################################################################################
##################################### ID LIST #####################################
###################################################################################

obj_flagged_id_list = [
    "002D", # Mumbo Token
    "0046", # Jiggy
    "0047", # Empty Honeycomb
    ]

obj_no_flag_id_list = [
    "0029", # Orange
    "0049", # 1-Up
    "005E", # Yellow Jinjo
    "005F", # Orange Jinjo
    "0060", # Blue Jinjo
    "0061", # Purple Jinjo
    "0062", # Green Jinjo
    # Sometimes Structs
#     "0052", # Egg
#     "0129", # Red Feather
#     "0370", # Gold Feather
    ]

collectable_struct_id_list = [
    "164000B4", # Note B4
    "164000B5", # Note B5
    "164000B6", # Note B6
    "164000B7", # Note B7
    "165000A0", # Blue Egg A0
    "165000A2", # Blue Egg A2
#     "00E000DC", # Red Feather DC
#     "00E000DD", # Red Feather DD
#     "00E000DE", # Red Feather DE
#     "15F000DF", # Gold Feather DF
#     "15F000DC", # Gold Feather DC
#     "15F000DE", # Gold Feather DE
    ]

ground_enemy_id_list = [
    "0004", # Bull
    "0005", # Ticker
    "0006", # Grublin
    "0012", # Beehive
    "0067", # Grublin
    "00C7", # RIP Tombstone
    #"0120", # Slappa (Purple Slappa)
    "034E", # Skeleton
    "034F", # Mummy
    "0350", # Sea Grublin
    #"0367", # Gruntling
    #"0375", # Grublin Hood
    "037D", # Ice Cube
    #"03BF", # Gruntling 2
    #"03C0", # Gruntling 3
    ]

flying_enemy_id_list = [
    "00CA", # Tee-Hee
    "0134", # Dragon Fly
    #"036D", # Coliwobble
    "0380", # Beetle
    ]

wall_enemy_id_list = [
    "013B", # Floatsam
    "01CC", # Chompa
    "029F", # Big Clucker
    ]

jumping_enemy_id_list = [
#     "0069", # Yum Yum
#     "0133", # Ribbit
#     "030D", # TNT Box Part 2
    "036E", # Bawl
    "036F", # Topper
    ]

non_collect_struct_id_list = [
    ]

#####################################################################################
##################################### FUNCTIONS #####################################
#####################################################################################

#######################
### DEVELOPER STUFF ###
#######################

##############
### SET UP ###
##############

def split_dir_rom(rom_dir):
    if("\\" in rom_dir):
        rom_file = rom_dir.split("\\")[-1]
    elif("/" in rom_dir):
        rom_file = rom_dir.split("/")[-1]
    else:
        print("File Directory Unfamiliar Format?")
    file_dir = rom_dir.replace(rom_file, "")
    return (file_dir, rom_file)

def setup_tmp_folder(file_dir):
    """Creates temporary folder that'll be used to store bin files and the randomized ROM."""
    print("Set Up Temporary Folder")
    if(not os.path.isdir(file_dir + tmp_folder)):
        os.mkdir(file_dir + tmp_folder)
    else:
        for filename in os.listdir(file_dir + tmp_folder):
            file_path = os.path.join(file_dir + tmp_folder, filename)
            try:
                if(os.path.isfile(file_path) or os.path.islink(file_path)):
                    os.unlink(file_path)
                elif(os.path.isdir(file_path)):
                    shutil.rmtree(file_path)
            except Exception as e:
                print('Failed to delete %s. Reason: %s' % (file_path, e))

def seed(seed_val=None):
    """If seed was not provided, generates a seed value."""
    print("Generate Seed")
    if((seed_val == None) or (seed_val == "")):
        seed_val = random.randint(10000000, 19940303)
    print("Seed: " + str(seed_val))
    return seed_val

def make_copy_of_rom(seed_val, file_dir, rom_file):
    """PyDoc"""
    print("Make Copy Of Rom")
    randomized_rom_file = file_dir + tmp_folder + "Banjo-Kazooie_Randomized_Seed_" + str(seed_val) + ".z64"
    shutil.copyfile(file_dir + rom_file, randomized_rom_file)

########################
### Parameter Window ###
########################

def verify_rom_and_gzip(rom_dir):
    (file_dir, rom_file) = split_dir_rom(rom_dir)
    rom_ext = rom_file.split(".")[-1]
    if(rom_ext != "z64"):
        print("Rom Extention is not allowed: " + rom_ext)
        exit(0)
    gzip_location = file_dir + "GZIP.EXE"
    if(not os.path.exists(gzip_location)):
        print("GZip Is Not In Folder")
        exit(0)

def verify_seed_val(seed_val):
    if((not seed_val.isdigit()) and (seed_val != "")):
        print("Seed value is not allowed: '" + seed_val + "'")
        exit(0)

def parameter_gui():
    def verify_parameters():
        verify_rom_and_gzip(rom_file_entry.get())
        verify_seed_val(seed_var.get())
        window.destroy()
    
    def UploadAction():
        cwd = os.getcwd()
        filename = tkinter.filedialog.askopenfilename(initialdir=cwd, title="Select A File", filetype =(("rom files","*.z64"),("all files","*.*")) )
        rom_file_entry.set(filename)
    
    window = tk.Tk()
    window.geometry('500x250')
    # Title? Idk if this is even needed
    window.winfo_toplevel().title("Banjo Kazooie Randomizer")
    # Select Rom File
    select_rom_button = tk.Button(window, text='Select Rom', command=UploadAction)
    select_rom_button.grid(row=0, column=0)
    rom_file_entry = tk.StringVar()
    rom_file_entry.set("")
    entry = tk.Entry(textvariable=rom_file_entry, state='readonly', width=50)
    entry.grid(row=1, column=0)
    # Seed Label And Entry
    seed_label = tk.Label(window, text='Would you like to insert a seed?')
    seed_label.grid(row=2, column=0)
    seed_var = tk.StringVar()
    seed_var.set("")
    seed_entry = tk.Entry(window, textvariable=seed_var)
    seed_entry.grid(row=3, column=0)
    # Select Rom
    # Radio Buttons For Non-Flag Object Options
    nf_obj_label = tk.Label(window, text='How Would You Like The Non-Flag Objects Randomized?')
    nf_obj_label.grid(row=4, column=0)
    nf_obj_var = tk.StringVar(window, "2")
    nf_obj_options = {
        "None": "1",
        "Local": "2",
        #"Completely": "3"
        }
    for (text, value) in nf_obj_options.items():
        nf_obj_select = tk.Radiobutton(window, text=text, variable=nf_obj_var, value=value, indicator=0)
        nf_obj_select.grid(row=4, column=value)
    # Radio Buttons For Flagged Objects Options
    f_obj_label = tk.Label(window, text='How Would You Like The Flagged Objects Randomized?')
    f_obj_label.grid(row=5, column=0)
    f_obj_var = tk.StringVar(window, "1")
    f_obj_options = {
        "None": "1",
        #"Local": "2",
        #"Completely": "3"
        }
    for (text, value) in f_obj_options.items():
        f_obj_select = tk.Radiobutton(window, text=text, variable=f_obj_var, value=value, indicator=0)
        f_obj_select.grid(row=5, column=value)
    # Radio Buttons For Struct Options
    struct_label = tk.Label(window, text='How Would You Like The Notes/Eggs/Feathers Randomized?')
    struct_label.grid(row=6, column=0)
    struct_var = tk.StringVar(window, "2")
    struct_options = {
        "None": "1",
        "Local": "2",
        "Completely": "3"
        }
    for (text, value) in struct_options.items():
        struct_select = tk.Radiobutton(window, text=text, variable=struct_var, value=value, indicator=0)
        struct_select.grid(row=6, column=value)
    # Radio Buttons For Enemy Options
    enemy_label = tk.Label(window, text='How Would You Like The Enemies Randomized?')
    enemy_label.grid(row=7, column=0)
    enemy_var = tk.StringVar(window, "2")
    enemy_options = {
        "None": "1",
        "Local": "2",
        "Completely": "3"
        }
    for (text, value) in enemy_options.items():
        enemy_select = tk.Radiobutton(window, text=text, variable=enemy_var, value=value, indicator=0)
        enemy_select.grid(row=7, column=value)
    # Button To Start Randomization
    start_label = tk.Label(window, text='Once finished, click submit!')
    start_label.grid(row=8, column=0)
    sub_btn = tk.Button(window, text='Submit', command=verify_parameters)
    sub_btn.grid(row=9, column=0)
    
    window.mainloop()
    return (rom_file_entry.get(), int(seed_var.get()), str(nf_obj_var.get()), str(f_obj_var.get()), str(struct_var.get()), str(enemy_var.get()))

#####################
### Decompression ###
#####################

def get_file_bytes(file_dir, rom_file):
    """PyDoc"""
    print("Get File Bytes")
    with open(file_dir + rom_file, "rb") as file:
        file_bytes = file.read()
    return file_bytes

def get_address_endpoints(file_bytes, addr):
    """PyDoc"""
    print("Get Address Endpoints")
    byte_list = []
    for byte_num in range(16):
        byte_val = str(hex(file_bytes[int(addr, 16) + byte_num])[2:])
        if(len(str(byte_val)) < 2):
            byte_val = "0" + byte_val
        byte_list.append(byte_val)
    address1 = int("0x" + byte_list[0] + byte_list[1] + byte_list[2] + byte_list[3], 16) + int("0x10CD0", 16)
    address2 = int("0x" + byte_list[8] + byte_list[9] + byte_list[10] + byte_list[11], 16) + int("0x10CD0", 16)
    print("Address Start: " + str(hex(address1)))
    print("Address End: " + str(hex(address2)))
    return (address1, address2)

def verify_original_header(file_bytes, address):
    """PyDoc"""
    print("Verify Original Header")
    if((file_bytes[address] != 17) or (file_bytes[address+1] != 114) or (file_bytes[address+2] != 0) or (file_bytes[address+3] != 0)):
        print("Does Not Start With 11 72 00 00")
        exit(0)

def decompress_file(file_dir, compressed_file):
    """PyDoc"""
    print("Decompress File")
    cmd = file_dir + "GZIP.EXE -dc " + file_dir + tmp_folder + compressed_file.upper() + "-Compressed.bin > " + file_dir + tmp_folder + compressed_file.upper() + "-Decompressed.bin"
    #print(cmd)
    os.system(cmd)

def decompressor(file_dir, rom_file):
    """PyDoc"""
    print("Decompressor")
    # Get File Bytes
    file_bytes = get_file_bytes(file_dir, rom_file)
    address_dict = {}
    address_translator = {}
    for location_name in setup_ids:
        address_list = []
        for (addr, header, footer, lead, tail) in setup_ids[location_name]:
            # Get Address Endpoints
            (address1, address2) = get_address_endpoints(file_bytes, addr)
            verify_original_header(file_bytes, address1)
            # Write Compressed File
            compressed_file = str(hex(address1)[2:]).upper()
            address_translator[addr] = compressed_file
            with open(file_dir + tmp_folder + compressed_file + "-Compressed.bin", "w+b") as comp_file:
                # Write Header
                for hex_val in header:
                    comp_file.write(bytes.fromhex(hex_val))
                # Grab Middle
                for index in range(address1+6, address2-len(tail)):
                #for index in range(address1, address2-len(tail)):
                    hex_string = str(hex(file_bytes[index]))[2:]
                    if(len(hex_string) < 2):
                        hex_string = "0" + hex_string
                    comp_file.write(bytes.fromhex(hex_string))
                # Write Footer
                for hex_val in footer:
                    comp_file.write(bytes.fromhex(hex_val))
            # Decompress File
            decompress_file(file_dir, compressed_file)
            address_list.append(compressed_file)
        address_dict[location_name] = address_list
    return (address_dict, address_translator)

###################
### Compression ###
###################

def compress_file(file_dir, decompressed_file):
    """PyDoc"""
    print("Compress File")
    cmd = file_dir + "GZIP.EXE -c " + file_dir + tmp_folder + decompressed_file.upper() + "-Decompressed.bin > " + file_dir + tmp_folder + decompressed_file.upper() + "-New_Compressed.bin"
    os.system(cmd)

def compressor(file_dir, location_setup, decompressed_file):
    """PyDoc"""
    print("Compressor")
    (addr, header, footer, lead, tail) = location_setup
    # Compress File
    compress_file(file_dir, decompressed_file)
    # Get Length Of Original Compressed File
    with open(file_dir + tmp_folder + decompressed_file + "-New_Compressed.bin", "r+b") as comp_file:
        mm_comp = mmap.mmap(comp_file.fileno(), 0)
        comp_file_len = len(mm_comp)
        header_end = ""
        for header_val in header[-4:]:
            header_end += header_val
        header_end_index = mm_comp.find(bytes.fromhex(header_end)) + 4
        with open(file_dir + tmp_folder + decompressed_file + "-Randomized_Compressed.bin", "w+b") as new_comp_file:
            for hex_val in lead:
                new_comp_file.write(bytes.fromhex(hex_val))
            for index in range(header_end_index, comp_file_len-len(footer)):
                hex_string = str(hex(mm_comp[index]))[2:]
                if(len(hex_string) < 2):
                    hex_string = "0" + hex_string
                new_comp_file.write(bytes.fromhex(hex_string))
            for hex_val in tail:
                new_comp_file.write(bytes.fromhex(hex_val))

def insert_files_into_rom(seed_val, file_dir, file_address):
    """PyDoc"""
    print("Insert Files Into Rom")
    with open(file_dir + tmp_folder + file_address + "-Randomized_Compressed.bin", "rb") as setup_bin:
        setup_content = setup_bin.read()
    with open(file_dir + tmp_folder + "Banjo-Kazooie_Randomized_Seed_" + str(seed_val) + ".z64", "r+b") as rand_rom:
        setup_count = 0
        for index in range(int(file_address, 16), int(file_address, 16) + len(setup_content)):
            mm = mmap.mmap(rand_rom.fileno(), 0)
            mm[index] = setup_content[setup_count]
            setup_count += 1

def compress_files(seed_val, file_dir, address_translator):
    """PyDoc"""
    print("Compress Files")
    for location in setup_ids:
        for location_setup in setup_ids[location]:
            file_address = address_translator[location_setup[0]]
            compressor(file_dir, location_setup, file_address)
            insert_files_into_rom(seed_val, file_dir, file_address)

######################
### GET INDEX LIST ###
######################

def get_flagged_object_index_list(mm, object_id, start=0):
    object_index = mm.find(bytes.fromhex("190C" + object_id), start)
    if(object_index == -1):
        return []
    else:
        new_start = int(object_index) + 1
        object_list = get_flagged_object_index_list(mm, object_id, start=new_start)
    object_list.append(object_index)
    return object_list

def get_no_flag_object_index_list(mm, object_id, start=0):
    object_index = mm.find(bytes.fromhex("190C" + object_id), start)
    if(object_index == -1):
        return []
    else:
        new_start = int(object_index) + 1
        object_list = get_no_flag_object_index_list(mm, object_id, start=new_start)
    object_list.append(object_index)
    return object_list

def get_struct_index_list(mm, struct_id, start=0):
    struct_index = mm.find(bytes.fromhex(struct_id), start)
    if(struct_index == -1):
        return []
    else:
        new_start = int(struct_index) + 1
        struct_list = get_struct_index_list(mm, struct_id, start=new_start)
    struct_list.append(struct_index)
    return struct_list

def get_enemy_index_list(mm, enemy_id, start=0):
    enemy_index = mm.find(bytes.fromhex("190C" + enemy_id), start)
    if(enemy_index == -1):
        return []
    else:
        new_start = int(enemy_index) + 1
        enemy_list = get_enemy_index_list(mm, enemy_id, start=new_start)
    enemy_list.append(enemy_index)
    return enemy_list

########################
### OBTAIN LIST INFO ###
########################

def obtain_no_flag_object_list_info(mm, no_flag_obj_index_list):
    #X-Loc  Y-Loc  Z-Loc  script   ID     --   --   --   --   rot.  size  --    --
    #0E48   0153   1998   190C     0049   00   00   00   00   00    64    0C    10
    object_location_list = []
    for object_index in no_flag_obj_index_list:
        object_dict = {}
#         object_dict["Hex_X1"] = mm[object_index - 6]
#         object_dict["Hex_X2"] = mm[object_index - 5]
#         object_dict["Hex_Y1"] = mm[object_index - 4]
#         object_dict["Hex_Y2"] = mm[object_index - 3]
#         object_dict["Hex_Z1"] = mm[object_index - 2]
#         object_dict["Hex_Z2"] = mm[object_index - 1]
        object_dict["Script1"] = mm[object_index]
        object_dict["Script2"] = mm[object_index + 1]
        object_dict["Obj_ID1"] = mm[object_index + 2]
        object_dict["Obj_ID2"] = mm[object_index + 3]
#         object_dict["Rotation"] = mm[object_index + 8]
#         object_dict["Size"] = mm[object_index + 9]
        object_location_list.append(object_dict)
    return object_location_list

def obtain_struct_list_info(mm, struct_list_index_list):
    #obj id  ????  x-loc  y-loc  z-loc  size  ??
    #1640    00B6  FA12   03C4   02C2   19    80
    struct_location_list = []
    for struct_index in struct_list_index_list:
        struct_dict = {}
        struct_dict["Obj_ID1"] = mm[struct_index]
        struct_dict["Obj_ID2"] = mm[struct_index + 1]
        struct_dict["IDK1"] = mm[struct_index + 2]
        struct_dict["IDK2"] = mm[struct_index + 3]
#         struct_dict["Hex_X1"] = mm[struct_index + 4]
#         struct_dict["Hex_X2"] = mm[struct_index + 5]
#         struct_dict["Hex_Y1"] = mm[struct_index + 6]
#         struct_dict["Hex_Y2"] = mm[struct_index + 7]
#         struct_dict["Hex_Z1"] = mm[struct_index + 8]
#         struct_dict["Hex_Z2"] = mm[struct_index + 9]
#         struct_dict["Size"] = mm[struct_index + 10]
#         struct_dict["IDK3"] = mm[struct_index + 11]
        struct_location_list.append(struct_dict)
    return struct_location_list

def obtain_enemy_list_info(mm, enemy_index_list):
    #X-Loc  Y-Loc  Z-Loc  script   ID     --   --   --   --   rot.  size  --    --
    #0E48   0153   1998   190C     0049   00   00   00   00   00    64    0C    10
    enemy_location_list = []
    for enemy_index in enemy_index_list:
        enemy_dict = {}
#         enemy_dict["Hex_X1"] = mm[enemy_index - 6]
#         enemy_dict["Hex_X2"] = mm[enemy_index - 5]
#         enemy_dict["Hex_Y1"] = mm[enemy_index - 4]
#         enemy_dict["Hex_Y2"] = mm[enemy_index - 3]
#         enemy_dict["Hex_Z1"] = mm[enemy_index - 2]
#         enemy_dict["Hex_Z2"] = mm[enemy_index - 1]
#         enemy_dict["Script1"] = mm[enemy_index]
#         enemy_dict["Script2"] = mm[enemy_index + 1]
        enemy_dict["Obj_ID1"] = mm[enemy_index + 2]
        enemy_dict["Obj_ID2"] = mm[enemy_index + 3]
#         enemy_dict["Rotation"] = mm[enemy_index + 8]
#         enemy_dict["Size"] = mm[enemy_index + 9]
        enemy_location_list.append(enemy_dict)
    return enemy_location_list

##################
### INDEX MAIN ###
##################

def create_mmap(file_dir, address):
    with open(file_dir + tmp_folder + address + "-Decompressed.bin", "r+b") as f:
        mm = mmap.mmap(f.fileno(), 0)
    return mm

def generic_get_lists(mm, id_list):
    index_list = []
    for obj_id in id_list:
        if(id_list == obj_no_flag_id_list):
            object_list = get_no_flag_object_index_list(mm, obj_id)
        elif(id_list == collectable_struct_id_list):
            object_list = get_struct_index_list(mm, obj_id)
        elif((id_list == ground_enemy_id_list) or
             (id_list == flying_enemy_id_list) or
             (id_list == wall_enemy_id_list) or
             (id_list == jumping_enemy_id_list)):
            object_list = get_enemy_index_list(mm, obj_id)
        else:
            print("Invalid ID List")
            exit(0)
        for item in object_list:
            index_list.append(item)
    if(id_list == obj_no_flag_id_list):
        location_list = obtain_no_flag_object_list_info(mm, index_list)
    elif(id_list == collectable_struct_id_list):
        location_list = obtain_struct_list_info(mm, index_list)
    elif((id_list == ground_enemy_id_list) or
         (id_list == flying_enemy_id_list) or
         (id_list == wall_enemy_id_list) or
         (id_list == jumping_enemy_id_list)):
        location_list = obtain_enemy_list_info(mm, index_list)
    else:
        print("Invalid ID List")
        exit(0)
    return (index_list, location_list)

def get_index_main(file_dir, address_dict, seed_val, non_flag_option, flagged_option, struct_option, enemy_option):
    for location in address_dict:
        address_index_dict = {}
        address_no_flag_object_location_list = []
        address_struct_location_list = []
        address_ground_enemy_location_list = []
        address_flying_enemy_location_list = []
        address_wall_enemy_location_list = []
        address_jumping_enemy_location_list = []
        for address in address_dict[location]:
            address_index_dict[address] = {}
            mm = create_mmap(file_dir, address)
            # No Flag Objects
            (no_flag_obj_index_list, no_flag_object_location_list) = generic_get_lists(mm, obj_no_flag_id_list)
            for item in no_flag_object_location_list:
                address_no_flag_object_location_list.append(item)
            address_index_dict[address]["No_Flag_Objects"] = no_flag_obj_index_list
            # Structs
            (struct_index_list, struct_location_list) = generic_get_lists(mm, collectable_struct_id_list)
            for item in struct_location_list:
                address_struct_location_list.append(item)
            address_index_dict[address]["Structs"] = struct_index_list
            # Grounded Enemies
            (ground_enemy_index_list, ground_enemy_location_list) = generic_get_lists(mm, ground_enemy_id_list)
            for item in ground_enemy_location_list:
                address_ground_enemy_location_list.append(item)
            address_index_dict[address]["Grounded_Enemies"] = ground_enemy_index_list
            # Flying Enemies
            (flying_enemy_index_list, flying_enemy_location_list) = generic_get_lists(mm, flying_enemy_id_list)
            for item in flying_enemy_location_list:
                address_flying_enemy_location_list.append(item)
            address_index_dict[address]["Flying_Enemies"] = flying_enemy_index_list
            # Wall Enemies
            (wall_enemy_index_list, wall_enemy_location_list) = generic_get_lists(mm, wall_enemy_id_list)
            for item in wall_enemy_location_list:
                address_wall_enemy_location_list.append(item)
            address_index_dict[address]["Wall_Enemies"] = wall_enemy_index_list
            # Jumping Enemies
            (jumping_enemy_index_list, jumping_enemy_location_list) = generic_get_lists(mm, jumping_enemy_id_list)
            for item in jumping_enemy_location_list:
                address_jumping_enemy_location_list.append(item)
            address_index_dict[address]["Jumping_Enemies"] = jumping_enemy_index_list

        ### Randomize The Lists
        address_no_flag_object_location_list = randomize_list(seed_val, address_no_flag_object_location_list)
        address_struct_location_list = randomize_list(seed_val, address_struct_location_list)
        address_ground_enemy_location_list = randomize_list(seed_val, address_ground_enemy_location_list)
        address_flying_enemy_location_list = randomize_list(seed_val, address_flying_enemy_location_list)
        address_wall_enemy_location_list = randomize_list(seed_val, address_wall_enemy_location_list)
        address_jumping_enemy_location_list = randomize_list(seed_val, address_jumping_enemy_location_list)
        
        ### Move The Objects
        for address in address_dict[location]:
            mm = create_mmap(file_dir, address)
            # No Flag Objects
            if(non_flag_option == "1"):
                print("Non-Flag Objects Randomization Off")
            elif(non_flag_option == "2"):
                move_no_flag_objects(mm, address_index_dict[address]["No_Flag_Objects"], address_no_flag_object_location_list)
            # Flagged Objects
            if(flagged_option == "1"):
                print("Flagged Objects Randomization Off")
            elif(flagged_option == "2"):
                print("Feature Currently Not Available")
            # Structs
            if(struct_option == "1"):
                print("Struct Randomization Off")
            elif(struct_option == "2"):
                move_structs(mm, address_index_dict[address]["Structs"], address_struct_location_list)
            # Enemies
            if(enemy_option == "1"):
                print("Enemy Randomization Off")
            elif(enemy_option == "2"):
                # Grounded Enemies
                address_ground_enemy_location_list = move_local_enemies(mm, address_index_dict[address]["Grounded_Enemies"], address_ground_enemy_location_list)
                # Flying Enemies
                address_flying_enemy_location_list = move_local_enemies(mm, address_index_dict[address]["Flying_Enemies"], address_flying_enemy_location_list)
                # Wall Enemies
                address_wall_enemy_location_list = move_local_enemies(mm, address_index_dict[address]["Wall_Enemies"], address_wall_enemy_location_list)
                # Jumping Enemies
                address_jumping_enemy_location_list = move_local_enemies(mm, address_index_dict[address]["Jumping_Enemies"], address_jumping_enemy_location_list)
            elif(enemy_option == "3"):
                # Grounded Enemies
                move_randomized_enemies(mm, seed_val, address_index_dict[address]["Grounded_Enemies"], ground_enemy_id_list)
                # Flying Enemies
                move_randomized_enemies(mm, seed_val, address_index_dict[address]["Flying_Enemies"], flying_enemy_id_list)
                # Wall Enemies
                move_randomized_enemies(mm, seed_val, address_index_dict[address]["Wall_Enemies"], wall_enemy_id_list)
                # Jumping Enemies
                move_randomized_enemies(mm, seed_val, address_index_dict[address]["Jumping_Enemies"], jumping_enemy_id_list)

#################
### RANDOMIZE ###
#################

def randomize_list(seed_val, original_list):
    random.seed(a=seed_val)
    random.shuffle(original_list)
    return original_list

def move_no_flag_objects(mm, obj_index_list, object_location_list):
    for object_index in obj_index_list:
        mm[object_index] = object_location_list[0]["Script1"]
        mm[object_index + 1] = object_location_list[0]["Script2"]
        mm[object_index + 2] = object_location_list[0]["Obj_ID1"]
        mm[object_index + 3] = object_location_list[0]["Obj_ID2"]
        object_location_list.pop(0)
    return object_location_list

def move_structs(mm, struct_index_list, struct_location_list):
    #print(struct_index_list)
    for struct_index in struct_index_list:
        mm[struct_index] = struct_location_list[0]["Obj_ID1"]
        mm[struct_index + 1] = struct_location_list[0]["Obj_ID2"]
#         mm[struct_index + 2] = struct_location_list[struct_count]["IDK1"]
#         mm[struct_index + 3] = struct_location_list[struct_count]["IDK2"]
        mm[struct_index + 2] = 0 #struct_location_list[struct_count]["IDK1"]
        mm[struct_index + 3] = 160 #struct_location_list[struct_count]["IDK2"]
        struct_location_list.pop(0)
    return struct_location_list

def move_local_enemies(mm, enemy_index_list, enemy_location_list):
    #print(enemy_index_list)
    for enemy_index in enemy_index_list:
#         mm[enemy_index] = enemy_location_list[enemy_count]["Script1"]
#         mm[enemy_index + 1] = enemy_location_list[enemy_count]["Script2"]
        mm[enemy_index + 2] = enemy_location_list[0]["Obj_ID1"]
        mm[enemy_index + 3] = enemy_location_list[0]["Obj_ID2"]
        enemy_location_list.pop(0)
    return enemy_location_list

def move_randomized_enemies(mm, seed_val, enemy_index_list, enemy_id_list):
    seed_count = 0
    for enemy_index in enemy_index_list:
        random.seed(a=(seed_val+seed_count))
        enemy_obj_id = random.choice(enemy_id_list)
        mm[enemy_index + 2] = int(enemy_obj_id[:2], 16)
        mm[enemy_index + 3] = int(enemy_obj_id[2:], 16)
        seed_count += 1

################
### CLEAN UP ###
################

def remove_bin_files(file_dir):
    """PyDoc"""
    for filename in os.listdir(file_dir + tmp_folder):
        file_path = os.path.join(file_dir + tmp_folder, filename)
        try:
            if((os.path.isfile(file_path) or os.path.islink(file_path)) and file_path.endswith("ompressed.bin")):
                os.unlink(file_path)
            elif(os.path.isdir(file_path)):
                shutil.rmtree(file_path)
        except Exception as e:
            print('Failed to delete %s. Reason: %s' % (file_path, e))

############
### MAIN ###
############

def main():
    """PyDoc"""
    ### Set Up ###
    (rom_dir, seed_val, non_flag_option, flagged_option, struct_option, enemy_option) = parameter_gui()
    (file_dir, rom_file) = split_dir_rom(rom_dir)
    setup_tmp_folder(file_dir)
    seed_val = seed(seed_val)
    make_copy_of_rom(seed_val, file_dir, rom_file)
    ### Decompress ROM ###
    (address_dict, address_translator) = decompressor(file_dir, rom_file)
    ### Randomize Indexes ###
    get_index_main(file_dir, address_dict, seed_val, non_flag_option, flagged_option, struct_option, enemy_option)
    ### Compress ROM ###
    compress_files(seed_val, file_dir, address_translator)
    ### Clean Up ###
    remove_bin_files(file_dir)

##########################################################################################
####################################### TEST CASES #######################################
##########################################################################################

print("Start")
main()
print("Done")
